{"ast":null,"code":"/*\r\nWHAT: SublimeText-like Fuzzy Search\r\n\r\nUSAGE:\r\n  fuzzysort.single('fs', 'Fuzzy Search') // {score: -16}\r\n  fuzzysort.single('test', 'test') // {score: 0}\r\n  fuzzysort.single('doesnt exist', 'target') // null\r\n\r\n  fuzzysort.go('mr', ['Monitor.cpp', 'MeshRenderer.cpp'])\r\n  // [{score: -18, target: \"MeshRenderer.cpp\"}, {score: -6009, target: \"Monitor.cpp\"}]\r\n\r\n  fuzzysort.highlight(fuzzysort.single('fs', 'Fuzzy Search'), '<b>', '</b>')\r\n  // <b>F</b>uzzy <b>S</b>earch\r\n*/\n// UMD (Universal Module Definition) for fuzzysort\n;\n\n(function (root, UMD) {\n  if (typeof define === 'function' && define.amd) define([], UMD);else if (typeof module === 'object' && module.exports) module.exports = UMD();else root.fuzzysort = UMD();\n})(this, function UMD() {\n  function fuzzysortNew(instanceOptions) {\n    var fuzzysort = {\n      single: function (search, target, options) {\n        if (!search) return null;\n        if (!isObj(search)) search = fuzzysort.getPreparedSearch(search);\n        if (!target) return null;\n        if (!isObj(target)) target = fuzzysort.getPrepared(target);\n        var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n        return algorithm(search, target, search[0]); // var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\n        // var result = algorithm(search, target, search[0])\n        // if(result === null) return null\n        // if(result.score < threshold) return null\n        // return result\n      },\n      go: function (search, targets, options) {\n        if (!search) return noResults;\n        search = fuzzysort.prepareSearch(search);\n        var searchLowerCode = search[0];\n        var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n        var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n        var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n        var resultsLen = 0;\n        var limitedCount = 0;\n        var targetsLen = targets.length; // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n        // options.keys\n\n        if (options && options.keys) {\n          var scoreFn = options.scoreFn || defaultScoreFn;\n          var keys = options.keys;\n          var keysLen = keys.length;\n\n          for (var i = targetsLen - 1; i >= 0; --i) {\n            var obj = targets[i];\n            var objResults = new Array(keysLen);\n\n            for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n              var key = keys[keyI];\n              var target = getValue(obj, key);\n\n              if (!target) {\n                objResults[keyI] = null;\n                continue;\n              }\n\n              if (!isObj(target)) target = fuzzysort.getPrepared(target);\n              objResults[keyI] = algorithm(search, target, searchLowerCode);\n            }\n\n            objResults.obj = obj; // before scoreFn so scoreFn can use it\n\n            var score = scoreFn(objResults);\n            if (score === null) continue;\n            if (score < threshold) continue;\n            objResults.score = score;\n\n            if (resultsLen < limit) {\n              q.add(objResults);\n              ++resultsLen;\n            } else {\n              ++limitedCount;\n              if (score > q.peek().score) q.replaceTop(objResults);\n            }\n          } // options.key\n\n        } else if (options && options.key) {\n          var key = options.key;\n\n          for (var i = targetsLen - 1; i >= 0; --i) {\n            var obj = targets[i];\n            var target = getValue(obj, key);\n            if (!target) continue;\n            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n            var result = algorithm(search, target, searchLowerCode);\n            if (result === null) continue;\n            if (result.score < threshold) continue; // have to clone result so duplicate targets from different obj can each reference the correct obj\n\n            result = {\n              target: result.target,\n              _targetLowerCodes: null,\n              _nextBeginningIndexes: null,\n              score: result.score,\n              indexes: result.indexes,\n              obj: obj\n            }; // hidden\n\n            if (resultsLen < limit) {\n              q.add(result);\n              ++resultsLen;\n            } else {\n              ++limitedCount;\n              if (result.score > q.peek().score) q.replaceTop(result);\n            }\n          } // no keys\n\n        } else {\n          for (var i = targetsLen - 1; i >= 0; --i) {\n            var target = targets[i];\n            if (!target) continue;\n            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n            var result = algorithm(search, target, searchLowerCode);\n            if (result === null) continue;\n            if (result.score < threshold) continue;\n\n            if (resultsLen < limit) {\n              q.add(result);\n              ++resultsLen;\n            } else {\n              ++limitedCount;\n              if (result.score > q.peek().score) q.replaceTop(result);\n            }\n          }\n        }\n\n        if (resultsLen === 0) return noResults;\n        var results = new Array(resultsLen);\n\n        for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();\n\n        results.total = resultsLen + limitedCount;\n        return results;\n      },\n      goAsync: function (search, targets, options) {\n        var canceled = false;\n        var p = new Promise(function (resolve, reject) {\n          if (!search) return resolve(noResults);\n          search = fuzzysort.prepareSearch(search);\n          var searchLowerCode = search[0];\n          var q = fastpriorityqueue();\n          var iCurrent = targets.length - 1;\n          var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n          var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n          var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n          var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n          var resultsLen = 0;\n          var limitedCount = 0;\n\n          function step() {\n            if (canceled) return reject('canceled');\n            var startMs = Date.now(); // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n            // options.keys\n\n            if (options && options.keys) {\n              var scoreFn = options.scoreFn || defaultScoreFn;\n              var keys = options.keys;\n              var keysLen = keys.length;\n\n              for (; iCurrent >= 0; --iCurrent) {\n                var obj = targets[iCurrent];\n                var objResults = new Array(keysLen);\n\n                for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                  var key = keys[keyI];\n                  var target = getValue(obj, key);\n\n                  if (!target) {\n                    objResults[keyI] = null;\n                    continue;\n                  }\n\n                  if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                  objResults[keyI] = algorithm(search, target, searchLowerCode);\n                }\n\n                objResults.obj = obj; // before scoreFn so scoreFn can use it\n\n                var score = scoreFn(objResults);\n                if (score === null) continue;\n                if (score < threshold) continue;\n                objResults.score = score;\n\n                if (resultsLen < limit) {\n                  q.add(objResults);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (score > q.peek().score) q.replaceTop(objResults);\n                }\n\n                if (iCurrent % 1000\n                /*itemsPerCheck*/\n                === 0) {\n                  if (Date.now() - startMs >= 10\n                  /*asyncInterval*/\n                  ) {\n                    isNode ? setImmediate(step) : setTimeout(step);\n                    return;\n                  }\n                }\n              } // options.key\n\n            } else if (options && options.key) {\n              var key = options.key;\n\n              for (; iCurrent >= 0; --iCurrent) {\n                var obj = targets[iCurrent];\n                var target = getValue(obj, key);\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue; // have to clone result so duplicate targets from different obj can each reference the correct obj\n\n                result = {\n                  target: result.target,\n                  _targetLowerCodes: null,\n                  _nextBeginningIndexes: null,\n                  score: result.score,\n                  indexes: result.indexes,\n                  obj: obj\n                }; // hidden\n\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n\n                if (iCurrent % 1000\n                /*itemsPerCheck*/\n                === 0) {\n                  if (Date.now() - startMs >= 10\n                  /*asyncInterval*/\n                  ) {\n                    isNode ? setImmediate(step) : setTimeout(step);\n                    return;\n                  }\n                }\n              } // no keys\n\n            } else {\n              for (; iCurrent >= 0; --iCurrent) {\n                var target = targets[iCurrent];\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue;\n\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n\n                if (iCurrent % 1000\n                /*itemsPerCheck*/\n                === 0) {\n                  if (Date.now() - startMs >= 10\n                  /*asyncInterval*/\n                  ) {\n                    isNode ? setImmediate(step) : setTimeout(step);\n                    return;\n                  }\n                }\n              }\n            }\n\n            if (resultsLen === 0) return resolve(noResults);\n            var results = new Array(resultsLen);\n\n            for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();\n\n            results.total = resultsLen + limitedCount;\n            resolve(results);\n          }\n\n          isNode ? setImmediate(step) : step();\n        });\n\n        p.cancel = function () {\n          canceled = true;\n        };\n\n        return p;\n      },\n      highlight: function (result, hOpen, hClose) {\n        if (result === null) return null;\n        if (hOpen === undefined) hOpen = '<b>';\n        if (hClose === undefined) hClose = '</b>';\n        var highlighted = '';\n        var matchesIndex = 0;\n        var opened = false;\n        var target = result.target;\n        var targetLen = target.length;\n        var matchesBest = result.indexes;\n\n        for (var i = 0; i < targetLen; ++i) {\n          var char = target[i];\n\n          if (matchesBest[matchesIndex] === i) {\n            ++matchesIndex;\n\n            if (!opened) {\n              opened = true;\n              highlighted += hOpen;\n            }\n\n            if (matchesIndex === matchesBest.length) {\n              highlighted += char + hClose + target.substr(i + 1);\n              break;\n            }\n          } else {\n            if (opened) {\n              opened = false;\n              highlighted += hClose;\n            }\n          }\n\n          highlighted += char;\n        }\n\n        return highlighted;\n      },\n      prepare: function (target) {\n        if (!target) return;\n        return {\n          target: target,\n          _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n          _nextBeginningIndexes: null,\n          score: null,\n          indexes: null,\n          obj: null\n        }; // hidden\n      },\n      prepareSlow: function (target) {\n        if (!target) return;\n        return {\n          target: target,\n          _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n          _nextBeginningIndexes: fuzzysort.prepareNextBeginningIndexes(target),\n          score: null,\n          indexes: null,\n          obj: null\n        }; // hidden\n      },\n      prepareSearch: function (search) {\n        if (!search) return;\n        return fuzzysort.prepareLowerCodes(search);\n      },\n      // Below this point is only internal code\n      // Below this point is only internal code\n      // Below this point is only internal code\n      // Below this point is only internal code\n      getPrepared: function (target) {\n        if (target.length > 999) return fuzzysort.prepare(target); // don't cache huge targets\n\n        var targetPrepared = preparedCache.get(target);\n        if (targetPrepared !== undefined) return targetPrepared;\n        targetPrepared = fuzzysort.prepare(target);\n        preparedCache.set(target, targetPrepared);\n        return targetPrepared;\n      },\n      getPreparedSearch: function (search) {\n        if (search.length > 999) return fuzzysort.prepareSearch(search); // don't cache huge searches\n\n        var searchPrepared = preparedSearchCache.get(search);\n        if (searchPrepared !== undefined) return searchPrepared;\n        searchPrepared = fuzzysort.prepareSearch(search);\n        preparedSearchCache.set(search, searchPrepared);\n        return searchPrepared;\n      },\n      algorithm: function (searchLowerCodes, prepared, searchLowerCode) {\n        var targetLowerCodes = prepared._targetLowerCodes;\n        var searchLen = searchLowerCodes.length;\n        var targetLen = targetLowerCodes.length;\n        var searchI = 0; // where we at\n\n        var targetI = 0; // where you at\n\n        var typoSimpleI = 0;\n        var matchesSimpleLen = 0; // very basic fuzzy match; to remove non-matching targets ASAP!\n        // walk through target. find sequential matches.\n        // if all chars aren't found then exit\n\n        for (;;) {\n          var isMatch = searchLowerCode === targetLowerCodes[targetI];\n\n          if (isMatch) {\n            matchesSimple[matchesSimpleLen++] = targetI;\n            ++searchI;\n            if (searchI === searchLen) break;\n            searchLowerCode = searchLowerCodes[typoSimpleI === 0 ? searchI : typoSimpleI === searchI ? searchI + 1 : typoSimpleI === searchI - 1 ? searchI - 1 : searchI];\n          }\n\n          ++targetI;\n\n          if (targetI >= targetLen) {\n            // Failed to find searchI\n            // Check for typo or exit\n            // we go as far as possible before trying to transpose\n            // then we transpose backwards until we reach the beginning\n            for (;;) {\n              if (searchI <= 1) return null; // not allowed to transpose first char\n\n              if (typoSimpleI === 0) {\n                // we haven't tried to transpose yet\n                --searchI;\n                var searchLowerCodeNew = searchLowerCodes[searchI];\n                if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n\n                typoSimpleI = searchI;\n              } else {\n                if (typoSimpleI === 1) return null; // reached the end of the line for transposing\n\n                --typoSimpleI;\n                searchI = typoSimpleI;\n                searchLowerCode = searchLowerCodes[searchI + 1];\n                var searchLowerCodeNew = searchLowerCodes[searchI];\n                if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n              }\n\n              matchesSimpleLen = searchI;\n              targetI = matchesSimple[matchesSimpleLen - 1] + 1;\n              break;\n            }\n          }\n        }\n\n        var searchI = 0;\n        var typoStrictI = 0;\n        var successStrict = false;\n        var matchesStrictLen = 0;\n        var nextBeginningIndexes = prepared._nextBeginningIndexes;\n        if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n        var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1]; // Our target string successfully matched all characters in sequence!\n        // Let's try a more advanced and strict test to improve the score\n        // only count it as a match if it's consecutive or a beginning character!\n\n        if (targetI !== targetLen) for (;;) {\n          if (targetI >= targetLen) {\n            // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n            if (searchI <= 0) {\n              // We failed to push chars forward for a better match\n              // transpose, starting from the beginning\n              ++typoStrictI;\n              if (typoStrictI > searchLen - 2) break;\n              if (searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI + 1]) continue; // doesn't make sense to transpose a repeat char\n\n              targetI = firstPossibleI;\n              continue;\n            }\n\n            --searchI;\n            var lastMatch = matchesStrict[--matchesStrictLen];\n            targetI = nextBeginningIndexes[lastMatch];\n          } else {\n            var isMatch = searchLowerCodes[typoStrictI === 0 ? searchI : typoStrictI === searchI ? searchI + 1 : typoStrictI === searchI - 1 ? searchI - 1 : searchI] === targetLowerCodes[targetI];\n\n            if (isMatch) {\n              matchesStrict[matchesStrictLen++] = targetI;\n              ++searchI;\n\n              if (searchI === searchLen) {\n                successStrict = true;\n                break;\n              }\n\n              ++targetI;\n            } else {\n              targetI = nextBeginningIndexes[targetI];\n            }\n          }\n        }\n        {\n          // tally up the score & keep track of matches for highlighting later\n          if (successStrict) {\n            var matchesBest = matchesStrict;\n            var matchesBestLen = matchesStrictLen;\n          } else {\n            var matchesBest = matchesSimple;\n            var matchesBestLen = matchesSimpleLen;\n          }\n\n          var score = 0;\n          var lastTargetI = -1;\n\n          for (var i = 0; i < searchLen; ++i) {\n            var targetI = matchesBest[i]; // score only goes down if they're not consecutive\n\n            if (lastTargetI !== targetI - 1) score -= targetI;\n            lastTargetI = targetI;\n          }\n\n          if (!successStrict) {\n            score *= 1000;\n            if (typoSimpleI !== 0) score += -20;\n            /*typoPenalty*/\n          } else {\n            if (typoStrictI !== 0) score += -20;\n            /*typoPenalty*/\n          }\n\n          score -= targetLen - searchLen;\n          prepared.score = score;\n          prepared.indexes = new Array(matchesBestLen);\n\n          for (var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i];\n\n          return prepared;\n        }\n      },\n      algorithmNoTypo: function (searchLowerCodes, prepared, searchLowerCode) {\n        var targetLowerCodes = prepared._targetLowerCodes;\n        var searchLen = searchLowerCodes.length;\n        var targetLen = targetLowerCodes.length;\n        var searchI = 0; // where we at\n\n        var targetI = 0; // where you at\n\n        var matchesSimpleLen = 0; // very basic fuzzy match; to remove non-matching targets ASAP!\n        // walk through target. find sequential matches.\n        // if all chars aren't found then exit\n\n        for (;;) {\n          var isMatch = searchLowerCode === targetLowerCodes[targetI];\n\n          if (isMatch) {\n            matchesSimple[matchesSimpleLen++] = targetI;\n            ++searchI;\n            if (searchI === searchLen) break;\n            searchLowerCode = searchLowerCodes[searchI];\n          }\n\n          ++targetI;\n          if (targetI >= targetLen) return null; // Failed to find searchI\n        }\n\n        var searchI = 0;\n        var successStrict = false;\n        var matchesStrictLen = 0;\n        var nextBeginningIndexes = prepared._nextBeginningIndexes;\n        if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n        var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1]; // Our target string successfully matched all characters in sequence!\n        // Let's try a more advanced and strict test to improve the score\n        // only count it as a match if it's consecutive or a beginning character!\n\n        if (targetI !== targetLen) for (;;) {\n          if (targetI >= targetLen) {\n            // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n            if (searchI <= 0) break; // We failed to push chars forward for a better match\n\n            --searchI;\n            var lastMatch = matchesStrict[--matchesStrictLen];\n            targetI = nextBeginningIndexes[lastMatch];\n          } else {\n            var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n\n            if (isMatch) {\n              matchesStrict[matchesStrictLen++] = targetI;\n              ++searchI;\n\n              if (searchI === searchLen) {\n                successStrict = true;\n                break;\n              }\n\n              ++targetI;\n            } else {\n              targetI = nextBeginningIndexes[targetI];\n            }\n          }\n        }\n        {\n          // tally up the score & keep track of matches for highlighting later\n          if (successStrict) {\n            var matchesBest = matchesStrict;\n            var matchesBestLen = matchesStrictLen;\n          } else {\n            var matchesBest = matchesSimple;\n            var matchesBestLen = matchesSimpleLen;\n          }\n\n          var score = 0;\n          var lastTargetI = -1;\n\n          for (var i = 0; i < searchLen; ++i) {\n            var targetI = matchesBest[i]; // score only goes down if they're not consecutive\n\n            if (lastTargetI !== targetI - 1) score -= targetI;\n            lastTargetI = targetI;\n          }\n\n          if (!successStrict) score *= 1000;\n          score -= targetLen - searchLen;\n          prepared.score = score;\n          prepared.indexes = new Array(matchesBestLen);\n\n          for (var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i];\n\n          return prepared;\n        }\n      },\n      prepareLowerCodes: function (str) {\n        var strLen = str.length;\n        var lowerCodes = []; // new Array(strLen)    sparse array is too slow\n\n        var lower = str.toLowerCase();\n\n        for (var i = 0; i < strLen; ++i) lowerCodes[i] = lower.charCodeAt(i);\n\n        return lowerCodes;\n      },\n      prepareBeginningIndexes: function (target) {\n        var targetLen = target.length;\n        var beginningIndexes = [];\n        var beginningIndexesLen = 0;\n        var wasUpper = false;\n        var wasAlphanum = false;\n\n        for (var i = 0; i < targetLen; ++i) {\n          var targetCode = target.charCodeAt(i);\n          var isUpper = targetCode >= 65 && targetCode <= 90;\n          var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n          var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n          wasUpper = isUpper;\n          wasAlphanum = isAlphanum;\n          if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n        }\n\n        return beginningIndexes;\n      },\n      prepareNextBeginningIndexes: function (target) {\n        var targetLen = target.length;\n        var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);\n        var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow\n\n        var lastIsBeginning = beginningIndexes[0];\n        var lastIsBeginningI = 0;\n\n        for (var i = 0; i < targetLen; ++i) {\n          if (lastIsBeginning > i) {\n            nextBeginningIndexes[i] = lastIsBeginning;\n          } else {\n            lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n            nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n          }\n        }\n\n        return nextBeginningIndexes;\n      },\n      cleanup: cleanup,\n      new: fuzzysortNew\n    };\n    return fuzzysort;\n  } // fuzzysortNew\n  // This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\n\n\n  var isNode = typeof require !== 'undefined' && typeof window === 'undefined'; // var MAX_INT = Number.MAX_SAFE_INTEGER\n  // var MIN_INT = Number.MIN_VALUE\n\n  var preparedCache = new Map();\n  var preparedSearchCache = new Map();\n  var noResults = [];\n  noResults.total = 0;\n  var matchesSimple = [];\n  var matchesStrict = [];\n\n  function cleanup() {\n    preparedCache.clear();\n    preparedSearchCache.clear();\n    matchesSimple = [];\n    matchesStrict = [];\n  }\n\n  function defaultScoreFn(a) {\n    var max = -9007199254740991;\n\n    for (var i = a.length - 1; i >= 0; --i) {\n      var result = a[i];\n      if (result === null) continue;\n      var score = result.score;\n      if (score > max) max = score;\n    }\n\n    if (max === -9007199254740991) return null;\n    return max;\n  } // prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n  // prop = 'key1.key2'        10ms\n  // prop = ['key1', 'key2']   27ms\n\n\n  function getValue(obj, prop) {\n    var tmp = obj[prop];\n    if (tmp !== undefined) return tmp;\n    var segs = prop;\n    if (!Array.isArray(prop)) segs = prop.split('.');\n    var len = segs.length;\n    var i = -1;\n\n    while (obj && ++i < len) obj = obj[segs[i]];\n\n    return obj;\n  }\n\n  function isObj(x) {\n    return typeof x === 'object';\n  } // faster as a function\n  // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n\n\n  var fastpriorityqueue = function () {\n    var r = [],\n        o = 0,\n        e = {};\n\n    function n() {\n      for (var e = 0, n = r[e], c = 1; c < o;) {\n        var f = c + 1;\n        e = c, f < o && r[f].score < r[c].score && (e = f), r[e - 1 >> 1] = r[e], c = 1 + (e << 1);\n      }\n\n      for (var a = e - 1 >> 1; e > 0 && n.score < r[a].score; a = (e = a) - 1 >> 1) r[e] = r[a];\n\n      r[e] = n;\n    }\n\n    return e.add = function (e) {\n      var n = o;\n      r[o++] = e;\n\n      for (var c = n - 1 >> 1; n > 0 && e.score < r[c].score; c = (n = c) - 1 >> 1) r[n] = r[c];\n\n      r[n] = e;\n    }, e.poll = function () {\n      if (0 !== o) {\n        var e = r[0];\n        return r[0] = r[--o], n(), e;\n      }\n    }, e.peek = function (e) {\n      if (0 !== o) return r[0];\n    }, e.replaceTop = function (o) {\n      r[0] = o, n();\n    }, e;\n  };\n\n  var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own\n\n  return fuzzysortNew();\n}); // UMD\n// TODO: (performance) wasm version!?\n// TODO: (performance) layout memory in an optimal way to go fast by avoiding cache misses\n// TODO: (performance) preparedCache is a memory leak\n// TODO: (like sublime) backslash === forwardslash\n// TODO: (performance) i have no idea how well optizmied the allowing typos algorithm is","map":{"version":3,"sources":["/home/kartik/Desktop/FoodFlex/node_modules/fuzzysort/fuzzysort.js"],"names":["root","UMD","define","amd","module","exports","fuzzysort","fuzzysortNew","instanceOptions","single","search","target","options","isObj","getPreparedSearch","getPrepared","allowTypo","undefined","algorithm","algorithmNoTypo","go","targets","noResults","prepareSearch","searchLowerCode","threshold","limit","resultsLen","limitedCount","targetsLen","length","keys","scoreFn","defaultScoreFn","keysLen","i","obj","objResults","Array","keyI","key","getValue","score","q","add","peek","replaceTop","result","_targetLowerCodes","_nextBeginningIndexes","indexes","results","poll","total","goAsync","canceled","p","Promise","resolve","reject","fastpriorityqueue","iCurrent","step","startMs","Date","now","isNode","setImmediate","setTimeout","cancel","highlight","hOpen","hClose","highlighted","matchesIndex","opened","targetLen","matchesBest","char","substr","prepare","prepareLowerCodes","prepareSlow","prepareNextBeginningIndexes","targetPrepared","preparedCache","get","set","searchPrepared","preparedSearchCache","searchLowerCodes","prepared","targetLowerCodes","searchLen","searchI","targetI","typoSimpleI","matchesSimpleLen","isMatch","matchesSimple","searchLowerCodeNew","typoStrictI","successStrict","matchesStrictLen","nextBeginningIndexes","firstPossibleI","lastMatch","matchesStrict","matchesBestLen","lastTargetI","str","strLen","lowerCodes","lower","toLowerCase","charCodeAt","prepareBeginningIndexes","beginningIndexes","beginningIndexesLen","wasUpper","wasAlphanum","targetCode","isUpper","isAlphanum","isBeginning","lastIsBeginning","lastIsBeginningI","cleanup","new","require","window","Map","clear","a","max","prop","tmp","segs","isArray","split","len","x","r","o","e","n","c","f"],"mappings":"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","sourcesContent":["/*\r\nWHAT: SublimeText-like Fuzzy Search\r\n\r\nUSAGE:\r\n  fuzzysort.single('fs', 'Fuzzy Search') // {score: -16}\r\n  fuzzysort.single('test', 'test') // {score: 0}\r\n  fuzzysort.single('doesnt exist', 'target') // null\r\n\r\n  fuzzysort.go('mr', ['Monitor.cpp', 'MeshRenderer.cpp'])\r\n  // [{score: -18, target: \"MeshRenderer.cpp\"}, {score: -6009, target: \"Monitor.cpp\"}]\r\n\r\n  fuzzysort.highlight(fuzzysort.single('fs', 'Fuzzy Search'), '<b>', '</b>')\r\n  // <b>F</b>uzzy <b>S</b>earch\r\n*/\r\n\r\n// UMD (Universal Module Definition) for fuzzysort\r\n;(function(root, UMD) {\r\n  if(typeof define === 'function' && define.amd) define([], UMD)\r\n  else if(typeof module === 'object' && module.exports) module.exports = UMD()\r\n  else root.fuzzysort = UMD()\r\n})(this, function UMD() { function fuzzysortNew(instanceOptions) {\r\n\r\n  var fuzzysort = {\r\n\r\n    single: function(search, target, options) {\r\n      if(!search) return null\r\n      if(!isObj(search)) search = fuzzysort.getPreparedSearch(search)\r\n\r\n      if(!target) return null\r\n      if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n      var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\r\n        : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\r\n        : true\r\n      var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\r\n      return algorithm(search, target, search[0])\r\n      // var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\r\n      // var result = algorithm(search, target, search[0])\r\n      // if(result === null) return null\r\n      // if(result.score < threshold) return null\r\n      // return result\r\n    },\r\n\r\n    go: function(search, targets, options) {\r\n      if(!search) return noResults\r\n      search = fuzzysort.prepareSearch(search)\r\n      var searchLowerCode = search[0]\r\n\r\n      var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\r\n      var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991\r\n      var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\r\n        : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\r\n        : true\r\n      var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\r\n      var resultsLen = 0; var limitedCount = 0\r\n      var targetsLen = targets.length\r\n\r\n      // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\r\n\r\n      // options.keys\r\n      if(options && options.keys) {\r\n        var scoreFn = options.scoreFn || defaultScoreFn\r\n        var keys = options.keys\r\n        var keysLen = keys.length\r\n        for(var i = targetsLen - 1; i >= 0; --i) { var obj = targets[i]\r\n          var objResults = new Array(keysLen)\r\n          for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\r\n            var key = keys[keyI]\r\n            var target = getValue(obj, key)\r\n            if(!target) { objResults[keyI] = null; continue }\r\n            if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n            objResults[keyI] = algorithm(search, target, searchLowerCode)\r\n          }\r\n          objResults.obj = obj // before scoreFn so scoreFn can use it\r\n          var score = scoreFn(objResults)\r\n          if(score === null) continue\r\n          if(score < threshold) continue\r\n          objResults.score = score\r\n          if(resultsLen < limit) { q.add(objResults); ++resultsLen }\r\n          else {\r\n            ++limitedCount\r\n            if(score > q.peek().score) q.replaceTop(objResults)\r\n          }\r\n        }\r\n\r\n      // options.key\r\n      } else if(options && options.key) {\r\n        var key = options.key\r\n        for(var i = targetsLen - 1; i >= 0; --i) { var obj = targets[i]\r\n          var target = getValue(obj, key)\r\n          if(!target) continue\r\n          if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n          var result = algorithm(search, target, searchLowerCode)\r\n          if(result === null) continue\r\n          if(result.score < threshold) continue\r\n\r\n          // have to clone result so duplicate targets from different obj can each reference the correct obj\r\n          result = {target:result.target, _targetLowerCodes:null, _nextBeginningIndexes:null, score:result.score, indexes:result.indexes, obj:obj} // hidden\r\n\r\n          if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n          else {\r\n            ++limitedCount\r\n            if(result.score > q.peek().score) q.replaceTop(result)\r\n          }\r\n        }\r\n\r\n      // no keys\r\n      } else {\r\n        for(var i = targetsLen - 1; i >= 0; --i) { var target = targets[i]\r\n          if(!target) continue\r\n          if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n          var result = algorithm(search, target, searchLowerCode)\r\n          if(result === null) continue\r\n          if(result.score < threshold) continue\r\n          if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n          else {\r\n            ++limitedCount\r\n            if(result.score > q.peek().score) q.replaceTop(result)\r\n          }\r\n        }\r\n      }\r\n\r\n      if(resultsLen === 0) return noResults\r\n      var results = new Array(resultsLen)\r\n      for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\r\n      results.total = resultsLen + limitedCount\r\n      return results\r\n    },\r\n\r\n    goAsync: function(search, targets, options) {\r\n      var canceled = false\r\n      var p = new Promise(function(resolve, reject) {\r\n        if(!search) return resolve(noResults)\r\n        search = fuzzysort.prepareSearch(search)\r\n        var searchLowerCode = search[0]\r\n\r\n        var q = fastpriorityqueue()\r\n        var iCurrent = targets.length - 1\r\n        var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\r\n        var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991\r\n        var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\r\n          : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\r\n          : true\r\n        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\r\n        var resultsLen = 0; var limitedCount = 0\r\n        function step() {\r\n          if(canceled) return reject('canceled')\r\n\r\n          var startMs = Date.now()\r\n\r\n          // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\r\n\r\n          // options.keys\r\n          if(options && options.keys) {\r\n            var scoreFn = options.scoreFn || defaultScoreFn\r\n            var keys = options.keys\r\n            var keysLen = keys.length\r\n            for(; iCurrent >= 0; --iCurrent) { var obj = targets[iCurrent]\r\n              var objResults = new Array(keysLen)\r\n              for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\r\n                var key = keys[keyI]\r\n                var target = getValue(obj, key)\r\n                if(!target) { objResults[keyI] = null; continue }\r\n                if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n                objResults[keyI] = algorithm(search, target, searchLowerCode)\r\n              }\r\n              objResults.obj = obj // before scoreFn so scoreFn can use it\r\n              var score = scoreFn(objResults)\r\n              if(score === null) continue\r\n              if(score < threshold) continue\r\n              objResults.score = score\r\n              if(resultsLen < limit) { q.add(objResults); ++resultsLen }\r\n              else {\r\n                ++limitedCount\r\n                if(score > q.peek().score) q.replaceTop(objResults)\r\n              }\r\n\r\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\r\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\r\n                  isNode?setImmediate(step):setTimeout(step)\r\n                  return\r\n                }\r\n              }\r\n            }\r\n\r\n          // options.key\r\n          } else if(options && options.key) {\r\n            var key = options.key\r\n            for(; iCurrent >= 0; --iCurrent) { var obj = targets[iCurrent]\r\n              var target = getValue(obj, key)\r\n              if(!target) continue\r\n              if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n              var result = algorithm(search, target, searchLowerCode)\r\n              if(result === null) continue\r\n              if(result.score < threshold) continue\r\n\r\n              // have to clone result so duplicate targets from different obj can each reference the correct obj\r\n              result = {target:result.target, _targetLowerCodes:null, _nextBeginningIndexes:null, score:result.score, indexes:result.indexes, obj:obj} // hidden\r\n\r\n              if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n              else {\r\n                ++limitedCount\r\n                if(result.score > q.peek().score) q.replaceTop(result)\r\n              }\r\n\r\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\r\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\r\n                  isNode?setImmediate(step):setTimeout(step)\r\n                  return\r\n                }\r\n              }\r\n            }\r\n\r\n          // no keys\r\n          } else {\r\n            for(; iCurrent >= 0; --iCurrent) { var target = targets[iCurrent]\r\n              if(!target) continue\r\n              if(!isObj(target)) target = fuzzysort.getPrepared(target)\r\n\r\n              var result = algorithm(search, target, searchLowerCode)\r\n              if(result === null) continue\r\n              if(result.score < threshold) continue\r\n              if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n              else {\r\n                ++limitedCount\r\n                if(result.score > q.peek().score) q.replaceTop(result)\r\n              }\r\n\r\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\r\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\r\n                  isNode?setImmediate(step):setTimeout(step)\r\n                  return\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if(resultsLen === 0) return resolve(noResults)\r\n          var results = new Array(resultsLen)\r\n          for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\r\n          results.total = resultsLen + limitedCount\r\n          resolve(results)\r\n        }\r\n\r\n        isNode?setImmediate(step):step()\r\n      })\r\n      p.cancel = function() { canceled = true }\r\n      return p\r\n    },\r\n\r\n    highlight: function(result, hOpen, hClose) {\r\n      if(result === null) return null\r\n      if(hOpen === undefined) hOpen = '<b>'\r\n      if(hClose === undefined) hClose = '</b>'\r\n      var highlighted = ''\r\n      var matchesIndex = 0\r\n      var opened = false\r\n      var target = result.target\r\n      var targetLen = target.length\r\n      var matchesBest = result.indexes\r\n      for(var i = 0; i < targetLen; ++i) { var char = target[i]\r\n        if(matchesBest[matchesIndex] === i) {\r\n          ++matchesIndex\r\n          if(!opened) { opened = true\r\n            highlighted += hOpen\r\n          }\r\n\r\n          if(matchesIndex === matchesBest.length) {\r\n            highlighted += char + hClose + target.substr(i+1)\r\n            break\r\n          }\r\n        } else {\r\n          if(opened) { opened = false\r\n            highlighted += hClose\r\n          }\r\n        }\r\n        highlighted += char\r\n      }\r\n\r\n      return highlighted\r\n    },\r\n\r\n    prepare: function(target) {\r\n      if(!target) return\r\n      return {target:target, _targetLowerCodes:fuzzysort.prepareLowerCodes(target), _nextBeginningIndexes:null, score:null, indexes:null, obj:null} // hidden\r\n    },\r\n    prepareSlow: function(target) {\r\n      if(!target) return\r\n      return {target:target, _targetLowerCodes:fuzzysort.prepareLowerCodes(target), _nextBeginningIndexes:fuzzysort.prepareNextBeginningIndexes(target), score:null, indexes:null, obj:null} // hidden\r\n    },\r\n    prepareSearch: function(search) {\r\n      if(!search) return\r\n      return fuzzysort.prepareLowerCodes(search)\r\n    },\r\n\r\n\r\n\r\n    // Below this point is only internal code\r\n    // Below this point is only internal code\r\n    // Below this point is only internal code\r\n    // Below this point is only internal code\r\n\r\n\r\n\r\n    getPrepared: function(target) {\r\n      if(target.length > 999) return fuzzysort.prepare(target) // don't cache huge targets\r\n      var targetPrepared = preparedCache.get(target)\r\n      if(targetPrepared !== undefined) return targetPrepared\r\n      targetPrepared = fuzzysort.prepare(target)\r\n      preparedCache.set(target, targetPrepared)\r\n      return targetPrepared\r\n    },\r\n    getPreparedSearch: function(search) {\r\n      if(search.length > 999) return fuzzysort.prepareSearch(search) // don't cache huge searches\r\n      var searchPrepared = preparedSearchCache.get(search)\r\n      if(searchPrepared !== undefined) return searchPrepared\r\n      searchPrepared = fuzzysort.prepareSearch(search)\r\n      preparedSearchCache.set(search, searchPrepared)\r\n      return searchPrepared\r\n    },\r\n\r\n    algorithm: function(searchLowerCodes, prepared, searchLowerCode) {\r\n      var targetLowerCodes = prepared._targetLowerCodes\r\n      var searchLen = searchLowerCodes.length\r\n      var targetLen = targetLowerCodes.length\r\n      var searchI = 0 // where we at\r\n      var targetI = 0 // where you at\r\n      var typoSimpleI = 0\r\n      var matchesSimpleLen = 0\r\n\r\n      // very basic fuzzy match; to remove non-matching targets ASAP!\r\n      // walk through target. find sequential matches.\r\n      // if all chars aren't found then exit\r\n      for(;;) {\r\n        var isMatch = searchLowerCode === targetLowerCodes[targetI]\r\n        if(isMatch) {\r\n          matchesSimple[matchesSimpleLen++] = targetI\r\n          ++searchI; if(searchI === searchLen) break\r\n          searchLowerCode = searchLowerCodes[typoSimpleI===0?searchI : (typoSimpleI===searchI?searchI+1 : (typoSimpleI===searchI-1?searchI-1 : searchI))]\r\n        }\r\n\r\n        ++targetI; if(targetI >= targetLen) { // Failed to find searchI\r\n          // Check for typo or exit\r\n          // we go as far as possible before trying to transpose\r\n          // then we transpose backwards until we reach the beginning\r\n          for(;;) {\r\n            if(searchI <= 1) return null // not allowed to transpose first char\r\n            if(typoSimpleI === 0) { // we haven't tried to transpose yet\r\n              --searchI\r\n              var searchLowerCodeNew = searchLowerCodes[searchI]\r\n              if(searchLowerCode === searchLowerCodeNew) continue // doesn't make sense to transpose a repeat char\r\n              typoSimpleI = searchI\r\n            } else {\r\n              if(typoSimpleI === 1) return null // reached the end of the line for transposing\r\n              --typoSimpleI\r\n              searchI = typoSimpleI\r\n              searchLowerCode = searchLowerCodes[searchI + 1]\r\n              var searchLowerCodeNew = searchLowerCodes[searchI]\r\n              if(searchLowerCode === searchLowerCodeNew) continue // doesn't make sense to transpose a repeat char\r\n            }\r\n            matchesSimpleLen = searchI\r\n            targetI = matchesSimple[matchesSimpleLen - 1] + 1\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      var searchI = 0\r\n      var typoStrictI = 0\r\n      var successStrict = false\r\n      var matchesStrictLen = 0\r\n\r\n      var nextBeginningIndexes = prepared._nextBeginningIndexes\r\n      if(nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target)\r\n      var firstPossibleI = targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\r\n\r\n      // Our target string successfully matched all characters in sequence!\r\n      // Let's try a more advanced and strict test to improve the score\r\n      // only count it as a match if it's consecutive or a beginning character!\r\n      if(targetI !== targetLen) for(;;) {\r\n        if(targetI >= targetLen) {\r\n          // We failed to find a good spot for this search char, go back to the previous search char and force it forward\r\n          if(searchI <= 0) { // We failed to push chars forward for a better match\r\n            // transpose, starting from the beginning\r\n            ++typoStrictI; if(typoStrictI > searchLen-2) break\r\n            if(searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI+1]) continue // doesn't make sense to transpose a repeat char\r\n            targetI = firstPossibleI\r\n            continue\r\n          }\r\n\r\n          --searchI\r\n          var lastMatch = matchesStrict[--matchesStrictLen]\r\n          targetI = nextBeginningIndexes[lastMatch]\r\n\r\n        } else {\r\n          var isMatch = searchLowerCodes[typoStrictI===0?searchI : (typoStrictI===searchI?searchI+1 : (typoStrictI===searchI-1?searchI-1 : searchI))] === targetLowerCodes[targetI]\r\n          if(isMatch) {\r\n            matchesStrict[matchesStrictLen++] = targetI\r\n            ++searchI; if(searchI === searchLen) { successStrict = true; break }\r\n            ++targetI\r\n          } else {\r\n            targetI = nextBeginningIndexes[targetI]\r\n          }\r\n        }\r\n      }\r\n\r\n      { // tally up the score & keep track of matches for highlighting later\r\n        if(successStrict) { var matchesBest = matchesStrict; var matchesBestLen = matchesStrictLen }\r\n        else { var matchesBest = matchesSimple; var matchesBestLen = matchesSimpleLen }\r\n        var score = 0\r\n        var lastTargetI = -1\r\n        for(var i = 0; i < searchLen; ++i) { var targetI = matchesBest[i]\r\n          // score only goes down if they're not consecutive\r\n          if(lastTargetI !== targetI - 1) score -= targetI\r\n          lastTargetI = targetI\r\n        }\r\n        if(!successStrict) {\r\n          score *= 1000\r\n          if(typoSimpleI !== 0) score += -20/*typoPenalty*/\r\n        } else {\r\n          if(typoStrictI !== 0) score += -20/*typoPenalty*/\r\n        }\r\n        score -= targetLen - searchLen\r\n        prepared.score = score\r\n        prepared.indexes = new Array(matchesBestLen); for(var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i]\r\n\r\n        return prepared\r\n      }\r\n    },\r\n\r\n    algorithmNoTypo: function(searchLowerCodes, prepared, searchLowerCode) {\r\n      var targetLowerCodes = prepared._targetLowerCodes\r\n      var searchLen = searchLowerCodes.length\r\n      var targetLen = targetLowerCodes.length\r\n      var searchI = 0 // where we at\r\n      var targetI = 0 // where you at\r\n      var matchesSimpleLen = 0\r\n\r\n      // very basic fuzzy match; to remove non-matching targets ASAP!\r\n      // walk through target. find sequential matches.\r\n      // if all chars aren't found then exit\r\n      for(;;) {\r\n        var isMatch = searchLowerCode === targetLowerCodes[targetI]\r\n        if(isMatch) {\r\n          matchesSimple[matchesSimpleLen++] = targetI\r\n          ++searchI; if(searchI === searchLen) break\r\n          searchLowerCode = searchLowerCodes[searchI]\r\n        }\r\n        ++targetI; if(targetI >= targetLen) return null // Failed to find searchI\r\n      }\r\n\r\n      var searchI = 0\r\n      var successStrict = false\r\n      var matchesStrictLen = 0\r\n\r\n      var nextBeginningIndexes = prepared._nextBeginningIndexes\r\n      if(nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target)\r\n      var firstPossibleI = targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\r\n\r\n      // Our target string successfully matched all characters in sequence!\r\n      // Let's try a more advanced and strict test to improve the score\r\n      // only count it as a match if it's consecutive or a beginning character!\r\n      if(targetI !== targetLen) for(;;) {\r\n        if(targetI >= targetLen) {\r\n          // We failed to find a good spot for this search char, go back to the previous search char and force it forward\r\n          if(searchI <= 0) break // We failed to push chars forward for a better match\r\n\r\n          --searchI\r\n          var lastMatch = matchesStrict[--matchesStrictLen]\r\n          targetI = nextBeginningIndexes[lastMatch]\r\n\r\n        } else {\r\n          var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI]\r\n          if(isMatch) {\r\n            matchesStrict[matchesStrictLen++] = targetI\r\n            ++searchI; if(searchI === searchLen) { successStrict = true; break }\r\n            ++targetI\r\n          } else {\r\n            targetI = nextBeginningIndexes[targetI]\r\n          }\r\n        }\r\n      }\r\n\r\n      { // tally up the score & keep track of matches for highlighting later\r\n        if(successStrict) { var matchesBest = matchesStrict; var matchesBestLen = matchesStrictLen }\r\n        else { var matchesBest = matchesSimple; var matchesBestLen = matchesSimpleLen }\r\n        var score = 0\r\n        var lastTargetI = -1\r\n        for(var i = 0; i < searchLen; ++i) { var targetI = matchesBest[i]\r\n          // score only goes down if they're not consecutive\r\n          if(lastTargetI !== targetI - 1) score -= targetI\r\n          lastTargetI = targetI\r\n        }\r\n        if(!successStrict) score *= 1000\r\n        score -= targetLen - searchLen\r\n        prepared.score = score\r\n        prepared.indexes = new Array(matchesBestLen); for(var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i]\r\n\r\n        return prepared\r\n      }\r\n    },\r\n\r\n    prepareLowerCodes: function(str) {\r\n      var strLen = str.length\r\n      var lowerCodes = [] // new Array(strLen)    sparse array is too slow\r\n      var lower = str.toLowerCase()\r\n      for(var i = 0; i < strLen; ++i) lowerCodes[i] = lower.charCodeAt(i)\r\n      return lowerCodes\r\n    },\r\n    prepareBeginningIndexes: function(target) {\r\n      var targetLen = target.length\r\n      var beginningIndexes = []; var beginningIndexesLen = 0\r\n      var wasUpper = false\r\n      var wasAlphanum = false\r\n      for(var i = 0; i < targetLen; ++i) {\r\n        var targetCode = target.charCodeAt(i)\r\n        var isUpper = targetCode>=65&&targetCode<=90\r\n        var isAlphanum = isUpper || targetCode>=97&&targetCode<=122 || targetCode>=48&&targetCode<=57\r\n        var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum\r\n        wasUpper = isUpper\r\n        wasAlphanum = isAlphanum\r\n        if(isBeginning) beginningIndexes[beginningIndexesLen++] = i\r\n      }\r\n      return beginningIndexes\r\n    },\r\n    prepareNextBeginningIndexes: function(target) {\r\n      var targetLen = target.length\r\n      var beginningIndexes = fuzzysort.prepareBeginningIndexes(target)\r\n      var nextBeginningIndexes = [] // new Array(targetLen)     sparse array is too slow\r\n      var lastIsBeginning = beginningIndexes[0]\r\n      var lastIsBeginningI = 0\r\n      for(var i = 0; i < targetLen; ++i) {\r\n        if(lastIsBeginning > i) {\r\n          nextBeginningIndexes[i] = lastIsBeginning\r\n        } else {\r\n          lastIsBeginning = beginningIndexes[++lastIsBeginningI]\r\n          nextBeginningIndexes[i] = lastIsBeginning===undefined ? targetLen : lastIsBeginning\r\n        }\r\n      }\r\n      return nextBeginningIndexes\r\n    },\r\n\r\n    cleanup: cleanup,\r\n    new: fuzzysortNew,\r\n  }\r\n  return fuzzysort\r\n} // fuzzysortNew\r\n\r\n// This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\r\nvar isNode = typeof require !== 'undefined' && typeof window === 'undefined'\r\n// var MAX_INT = Number.MAX_SAFE_INTEGER\r\n// var MIN_INT = Number.MIN_VALUE\r\nvar preparedCache = new Map()\r\nvar preparedSearchCache = new Map()\r\nvar noResults = []; noResults.total = 0\r\nvar matchesSimple = []; var matchesStrict = []\r\nfunction cleanup() { preparedCache.clear(); preparedSearchCache.clear(); matchesSimple = []; matchesStrict = [] }\r\nfunction defaultScoreFn(a) {\r\n  var max = -9007199254740991\r\n  for (var i = a.length - 1; i >= 0; --i) {\r\n    var result = a[i]; if(result === null) continue\r\n    var score = result.score\r\n    if(score > max) max = score\r\n  }\r\n  if(max === -9007199254740991) return null\r\n  return max\r\n}\r\n\r\n// prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\r\n// prop = 'key1.key2'        10ms\r\n// prop = ['key1', 'key2']   27ms\r\nfunction getValue(obj, prop) {\r\n  var tmp = obj[prop]; if(tmp !== undefined) return tmp\r\n  var segs = prop\r\n  if(!Array.isArray(prop)) segs = prop.split('.')\r\n  var len = segs.length\r\n  var i = -1\r\n  while (obj && (++i < len)) obj = obj[segs[i]]\r\n  return obj\r\n}\r\n\r\nfunction isObj(x) { return typeof x === 'object' } // faster as a function\r\n\r\n// Hacked version of https://github.com/lemire/FastPriorityQueue.js\r\nvar fastpriorityqueue=function(){var r=[],o=0,e={};function n(){for(var e=0,n=r[e],c=1;c<o;){var f=c+1;e=c,f<o&&r[f].score<r[c].score&&(e=f),r[e-1>>1]=r[e],c=1+(e<<1)}for(var a=e-1>>1;e>0&&n.score<r[a].score;a=(e=a)-1>>1)r[e]=r[a];r[e]=n}return e.add=function(e){var n=o;r[o++]=e;for(var c=n-1>>1;n>0&&e.score<r[c].score;c=(n=c)-1>>1)r[n]=r[c];r[n]=e},e.poll=function(){if(0!==o){var e=r[0];return r[0]=r[--o],n(),e}},e.peek=function(e){if(0!==o)return r[0]},e.replaceTop=function(o){r[0]=o,n()},e};\r\nvar q = fastpriorityqueue() // reuse this, except for async, it needs to make its own\r\n\r\nreturn fuzzysortNew()\r\n}) // UMD\r\n\r\n// TODO: (performance) wasm version!?\r\n\r\n// TODO: (performance) layout memory in an optimal way to go fast by avoiding cache misses\r\n\r\n// TODO: (performance) preparedCache is a memory leak\r\n\r\n// TODO: (like sublime) backslash === forwardslash\r\n\r\n// TODO: (performance) i have no idea how well optizmied the allowing typos algorithm is\r\n"]},"metadata":{},"sourceType":"script"}